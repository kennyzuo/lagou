# 左政 ｜ Part 1 | 模块一

## 简答题


### 第一题

最终执行结果为：打印出 10。

原因是因为 var 关键字没有块级作用域，i 变量虽然是在 for 循环中定义，因为变量提升的原因，其实等同于在代码的开始定义了 i， 所以最终打印的 i 值是循环之后的结果

- code/task-01.js

### 第二题

最终执行结果为：打印出异常。

原因是因为在 let 声明变量之前使用，由于 TDZ（暂时性死区）的存在，会报错

- code/task-02.js

### 第三题

- code/task-03.js


### 第四题：请详细说明 var，let，const 三种声明变量的方式之间的具体差别？

- var，let，const 都是用来定义变量的
- var 定义的变量会提升到函数作用域（全局作用域）顶部， let 与 const 虽然会提升但是由于 TDZ（暂时性死区）的存在，若在声明之前使用会报错
- let 与 const 定义的变量有块级作用域，var 没有
- let 与 const 区别在与，let 可以在变量声明后重新赋值，const 不可以


### 第五题

最终执行结果为：20

原因是因为 setTimeout 内部匿名函数使用了箭头函数，它不会改变 this 指向

> 箭头函数不会创建自己的 this,它只会从自己的作用域链的上一层继承 this

所以这里的 this 就是 obj（从 task-04.js 的打印结果看也证明了这一点）

- code/task-04.js


### 第六题：简述 Symbol 用途

- 可以给对象定义唯一的键值，避免在扩展第三方模块时候键值冲突
- 可以给对象定义私有的成员

- code/task-05.js



### 第七题：说说什么是浅拷贝什么是深拷贝

- 浅拷贝什么是深拷贝都是针对像 Object, Array 这样的复杂对象的
- 浅拷贝只会复制一层对象的属性，而深拷贝会递归复制所有层级
- 浅拷贝在复制复杂对象时，如果对象的属性是 Array、Object 复杂对象，那么它拷贝的只是这些对象的引用，也就是说当你去修改这些对象的属性值时，目标对象和浅拷贝对象的值都将发生变化
- JSON stringify parse 可以实现简单深拷贝， Object.assign 实现的是浅拷贝

- code/task-06.js


### 第八题：如何理解 JS 异步编程， Event Loop 是做什么的， 什么是宏任务， 什么是微任务

历史原因 JS代码是单线程执行的，所以在进行一些类似网络请求，操作文件的耗时操作时，我们需要通过异步的方式来避免将主线程卡死。基于Event Loop 循环队列回掉函数方式是 JavaScript 异步的一种实现；Event Loop 本质上是一个队列，当异步操作有了结果之后，会将 callback 放置到队列中，等待 JS 主线程执行完毕之后，从队列中取出 callback 执行；

简单理解宏任务就是放置在 event loop 的每个任务， 而微任务的表现是在一个 js 主线程执行一个 tick 中的任务穿插，他们的粒度是不同的。

典型的宏任务有 setTimeout、requestAnimationFrame 等， 而微任务则有 Promise、MutationObserver 等

### 第九题

- code/task-07.js

### 第十题：简述 TS 与 JS 之间关系

- TS 是 JS 的超集
- TS 比 JS 多了 类型系统以及 ES6+ 新特性支持

### 第十一题：TS 的优缺点

优点
- 强大的类型系统
- ES6+ 新特性支持
- 良好的生态和开发工具支持

缺点

- 学习成本
- 项目初期会增加项目一些复杂度


## 编程题
 
手写 MyPromise 实现，尽可能还原 Promise 中的每一个 API，并通过注释的方式，描述思路和原理



